<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fruit Slicer Deluxe</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- GSAP for animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <style>
        /* Custom styles for the game elements */
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@500;700&display=swap');
        
        body {
            font-family: 'Fredoka', sans-serif;
            cursor: none; /* Hide default cursor */
            overflow: hidden;
        }

        /* Full screen stages */
        .stage {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            user-select: none;
            pointer-events: none; /* Stage itself should not block pointer events */
        }

        .stage-bg {
            /* Better background gradient, starting dark green for a 'garden' feel */
            background: linear-gradient(180deg, rgba(34, 139, 34, 0.1) 0%, rgba(34, 139, 34, 0.6) 70%, rgba(0, 0, 0, 0.8) 100%);
        }

        /* The falling vegetable/fruit elements - Base size will be set by JS but we use a responsive approach here for the dagger */
        .stage-bg > div, .stage-fg > div {
            /* Fallback font size for fruits */
            font-size: 15vw; 
            position: absolute;
            left: 0;
            top: 0;
            filter: drop-shadow(0 0 10px rgba(0,0,0,0.5));
            pointer-events: none;
            will-change: transform;
        }

        /* The cursor/dagger follower */
        .follower {
            /* Responsive font size for dagger */
            font-size: 20vw; 
            pointer-events: none;
            transform-origin: 50% 50%;
        }
        
        /* Clamp sizes for larger screens using media query */
        @media (min-width: 640px) { /* sm breakpoint and up */
            .stage-bg > div, .stage-fg > div {
                font-size: 6rem; 
            }
            .follower {
                font-size: 8rem;
            }
        }

        .dagger {
            transform: rotate(125deg) translateX(-50%) translateY(-50%);
            will-change: transform;
        }

        /* Slicing effect mark */
        .stage-fg > .mark {
            font-size: 3rem;
            color: #FFD700;
        }

        /* Game UI */
        .game-ui {
            pointer-events: none; /* Ensures the game area below is still clickable */
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <!-- The Stages -->
    <div class="stage stage-bg"></div>
    <div class="stage stage-fg"></div>

    <!-- Game UI (Score, Timer) -->
    <div class="absolute top-0 left-0 w-full p-4 flex justify-between items-center game-ui z-50">
        <!-- Score Display (Responsive font sizing) -->
        <div id="score" class="text-3xl sm:text-4xl md:text-5xl font-extrabold text-yellow-300 drop-shadow-lg">
            Sliced 0
            <span class="text-xl sm:text-2xl text-yellow-100/70">/ 0</span>
        </div>

        <!-- Timer/Replay Area (Responsive font sizing and spacing) -->
        <div id="timer" class="flex items-center space-x-1 sm:space-x-2 cursor-pointer transition-all hover:scale-105" onclick="handleTimerClick()">
            <div id="timer-outter" class="text-5xl sm:text-6xl">‚è≤Ô∏è</div>
            <div id="timer-face" class="w-10 h-10 sm:w-12 sm:h-12 rounded-full overflow-hidden absolute ml-2 sm:ml-3">
                <div id="timer-inner" class="text-5xl sm:text-6xl absolute -translate-x-1 -translate-y-2">‚è≤Ô∏è</div>
            </div>
            <!-- Replay Button Overlay (Responsive positioning and size) -->
            <div id="replay-btn" class="absolute left-16 sm:left-24 text-2xl sm:text-3xl font-bold text-red-500 opacity-0 transition-opacity">
                ‚¨ÖÔ∏è Replay?
            </div>
        </div>
    </div>
    
    <!-- Start Screen Overlay (Responsive font sizing) -->
    <div id="start-screen" class="absolute inset-0 bg-gray-900/95 flex flex-col justify-center items-center z-50">
        <h1 class="text-4xl sm:text-6xl font-bold text-yellow-400 mb-4 animate-pulse">FRUIT SLICER</h1>
        <p class="text-lg sm:text-2xl text-white mb-8 text-center px-4">Click and drag to slice the veggies before time runs out!</p>
        <button id="start-btn" class="bg-green-600 hover:bg-green-700 text-white font-extrabold py-3 px-6 sm:py-4 sm:px-8 rounded-xl shadow-xl transition transform hover:scale-105 active:scale-95">
            START GAME
        </button>
    </div>

    <!-- Cursor Follower (Dagger) -->
    <div class="follower absolute top-0 left-0" id="follower">
        <div class="dagger" id="dagger">üó°Ô∏è</div>
    </div>

    <script>
        // --- GAME LOGIC ---

        // --- DOM Elements ---
        const stageBg = document.querySelector('.stage-bg');
        const stageFg = document.querySelector('.stage-fg');
        const scoreEl = document.getElementById('score');
        const timerOutter = document.getElementById('timer-outter');
        const timerFace = document.getElementById('timer-face');
        const replayBtn = document.getElementById('replay-btn');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-btn');
        const follower = document.getElementById('follower');
        const dagger = document.getElementById('dagger');

        // --- Game State ---
        const veg = ['üåΩ','üçÖ','ü•ï','üçÜ','ü•¨','ü•î','ü•¶','üßÖ','üßÑ','üå∂Ô∏è','ü•í', 'üçé', 'üçå', 'ü•ù', 'üçâ', 'üçç'];
        const vegTLs = []; // Array to hold individual vegetable GSAP timelines
        const props = { x: 0, dir: 1, isGameRunning: false };
        let vegNum = 0; // Total veggies spawned
        let pts = 0;    // Points (sliced veggies)
        let timeScale = 1; // Used for the slow-motion power-up
        const GAME_DURATION_REPEATS = 50; // How many veggies to spawn over time
        const TIME_POWERUP_DELAY = 5000; // 5 seconds slow-mo
        let vegTL; // Main vegetable spawn timeline
        let timerTL; // Main game timer timeline
        let gameTimerDuration = 0; // Will be calculated after vegTL setup

        // --- Responsive Scaling Helper ---
        const getResponsiveFactor = () => {
            // Determine a scaling factor based on the current window width
            if (window.innerWidth < 640) return 0.6; // Mobile (scale down)
            if (window.innerWidth < 1024) return 0.8; // Tablet (slight scale down)
            return 1; // Desktop (base size)
        }

        // --- GSAP Setup ---
        gsap.set(follower, { filter: 'drop-shadow(30px 30px 4px rgba(0,0,0,0.1))' });
        gsap.set(dagger, { rotate: 125, xPercent: -50, yPercent: -55 });
        gsap.set(timerFace, { transformOrigin: '50% 50%' });

        /**
         * Converts window coordinates (client) to coordinates relative to the stage.
         * Useful for touch/mobile devices.
         * @param {PointerEvent} e 
         * @returns {{x: number, y: number}}
         */
        const getPointerCoords = (e) => {
            // Check for touch events
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX,
                y: clientY
            };
        };

        // --- Core Game Functions ---

        /**
         * Checks if the dagger has "sliced" any vegetable near the pointer down location.
         * @param {PointerEvent} e 
         */
        const checkSlice = (e) => {
            const { x: pointerX, y: pointerY } = getPointerCoords(e);
            
            // Dagger position offset (relative to the follower's center)
            // Note: These offsets should be relatively constant regardless of scale, 
            // but the hit radius must be responsive.
            const daggerOffsetX = 84 * getResponsiveFactor(); 
            const daggerOffsetY = -25 * getResponsiveFactor();
            
            const daggerX = pointerX + daggerOffsetX;
            const daggerY = pointerY + daggerOffsetY;

            // Add a temporary visual mark for the slice impact
            const mark = document.createElement('div');
            mark.className = 'mark';
            stageFg.append(mark);
            gsap.fromTo(mark, 
                { innerHTML: 'üí•', x: daggerX - 50, y: daggerY - 50, rotate: 'random(0,360)', opacity: 1, scale: 0.5 }, 
                { duration: 0.3, scale: 2, opacity: 0, ease: 'power1.out', onComplete: () => mark.remove() }
            );

            // Iterate backwards for safer removal/re-parenting
            for (let i = stageBg.children.length - 1; i >= 0; i--) {
                const item = stageBg.children[i];
                
                // Get the current center position of the falling item
                const itemX = gsap.getProperty(item, 'x');
                const itemY = gsap.getProperty(item, 'y');
                
                // Calculate distance from the dagger tip to the item center
                const dX = Math.abs(itemX - daggerX);
                const dY = Math.abs(itemY - daggerY);
                const dist = Math.sqrt(dX * dX + dY * dY); 

                // SLICE_RADIUS is now scaled based on screen size
                const SLICE_RADIUS = 80 * getResponsiveFactor();

                if (dist < SLICE_RADIUS) {
                    // Check for Time Power-up (‚è±Ô∏è)
                    if (item.innerHTML === '‚è±Ô∏è') {
                        timeScale = 0.2;
                        gsap.to(vegTLs, { timeScale: timeScale, duration: 0.5 });
                        gsap.to('.stage-bg', { 
                            background: 'linear-gradient(rgba(0,120,230,0.5) 77%,rgba(0,100,255,0.9))',
                            duration: 0.5
                        });
                        
                        // Schedule time scale reset
                        gsap.delayedCall(TIME_POWERUP_DELAY / 1000, () => {
                            timeScale = 1;
                            gsap.to(vegTLs, { timeScale: 1, duration: 0.8 });
                            gsap.to('.stage-bg', { 
                                background: 'linear-gradient(180deg, rgba(34, 139, 34, 0.1) 0%, rgba(34, 139, 34, 0.6) 70%, rgba(0, 0, 0, 0.8) 100%)',
                                duration: 0.8
                            });
                        });
                    }

                    // Score point
                    pts++;
                    scoreEl.innerHTML = `Sliced ${pts}<span class="text-xl sm:text-2xl text-yellow-100/70"> / ${vegNum}</span>`;
                    
                    // Slicing animation (move to foreground stage, then explode)
                    stageFg.append(item);
                    
                    // Remove the corresponding timeline from the array
                    const indexToRemove = vegTLs.findIndex(tl => tl.vars.id === item.id);
                    if (indexToRemove > -1) {
                         // Stop the timeline and remove it from the array
                        vegTLs[indexToRemove].kill(); 
                        vegTLs.splice(indexToRemove, 1);
                    }

                    gsap.timeline({defaults: {ease: 'power1.out'}})
                        .set(item, { 
                            innerHTML: '‚ú®', // Change to a slice/starburst emoji
                            rotate: 'random(0,360)', 
                            filter: 'drop-shadow(0px 0px 0px rgba(0,0,0,0))' // Remove shadow for explosion
                        })
                        .to(item, { duration: 0.1, scale: 2, x: itemX + gsap.utils.random(-20, 20), y: itemY + gsap.utils.random(-20, 20) })
                        .to(item, { duration: 0.3, scale: 0, opacity: 0, ease: 'expo.in', onComplete: () => item.remove() }, 0.1);
                }
            }
        };

        /**
         * Adds a new vegetable/fruit element and its falling animation timeline.
         */
        function addVeg() {
            vegNum++;
            scoreEl.innerHTML = `Sliced ${pts}<span class="text-xl sm:text-2xl text-yellow-100/70"> / ${vegNum}</span>`;

            const f = document.createElement('div');
            f.id = `veg-${vegNum}`; // Give it an ID for easier tracking
            stageBg.append(f);

            // Determine if it's a power-up (Timer)
            const isPowerUp = (vegNum === 8 || vegNum === 36);
            const content = isPowerUp ? '‚è±Ô∏è' : veg[gsap.utils.random(0, veg.length - 1, 1)];
            
            // Responsive size calculation
            const scaleFactor = getResponsiveFactor();
            const baseMinSize = 90;
            const baseMaxSize = 120;

            // Create the animation timeline
            const tl = gsap.timeline({
                id: f.id,
                onComplete: () => { 
                    f.remove(); 
                    // Remove timeline from array when it naturally completes (missed slice)
                    const indexToRemove = vegTLs.findIndex(item => item.vars.id === f.id);
                    if (indexToRemove > -1) {
                        vegTLs.splice(indexToRemove, 1);
                    }
                }
            })
            .fromTo(f, {
                innerHTML: content,
                // Apply responsive font size
                fontSize: gsap.utils.random(baseMinSize * scaleFactor, baseMaxSize * scaleFactor), 
                xPercent: -50,
                yPercent: -50,
                y: innerHeight + 99, // Start off-screen bottom
                x: gsap.utils.random(innerWidth * 0.1, innerWidth * 0.9, 1),
                rotate: (vegNum % 2 === 0) ? 10 : -10,
                filter: 'drop-shadow(20px -10px 4px rgba(0,0,0,0.2))'
            }, {
                duration: 3,
                x: '+=random(-200,200)',
                rotate: (vegNum % 2 === 0) ? -10 : 10,
                ease: 'none' // Linear horizontal movement
            })
            .to(f, {
                y: gsap.utils.random(innerHeight * 0.1, innerHeight * 0.5, 1), // Mid-air jump height
                filter: 'drop-shadow(30px 30px 4px rgba(0,0,0,0.1))',
                duration: 1.5,
                yoyo: true,
                repeat: 1,
                ease: 'power1.out'
            }, 0)
            .timeScale(timeScale); // Apply current time scale (slow-mo)

            vegTLs.push(tl);
        }

        /**
         * Ends the game, shows the final score, and enables the replay button.
         */
        function gameEnd() {
            props.isGameRunning = false;
            
            // Stop the cursor movement listener
            window.onpointermove = null;
            // Also stop touch listeners for mobile
            window.onpointerdown = null;
            window.onpointerup = null;
            
            // Final score message (optional)
            console.log(`Game Over! Final Score: ${pts} / ${vegNum}`);

            gsap.timeline()
                .fromTo(replayBtn, {
                    opacity: 0,
                    x: 100
                }, {
                    ease: 'back.out(3)',
                    opacity: 1,
                    x: 0,
                    duration: 0.5
                });
        }
        
        /**
         * Initializes and starts the game timelines.
         */
        function startGame() {
            // Reset state
            pts = 0;
            vegNum = 0;
            timeScale = 1;
            scoreEl.innerHTML = `Sliced 0<span class="text-xl sm:text-2xl text-yellow-100/70"> / 0</span>`;
            gsap.set(replayBtn, { opacity: 0 });
            gsap.set(startScreen, { autoAlpha: 0, pointerEvents: 'none' });

            // Clear any lingering veggies
            stageBg.innerHTML = '';
            stageFg.innerHTML = '';
            vegTLs.length = 0;
            
            // --- Attach Pointer Listeners (Unified for Mouse/Touch) ---
            window.onpointerdown = handlePointerDown;
            window.onpointerup = handlePointerUp;
            window.onpointermove = handlePointerMove;
            
            props.isGameRunning = true;

            // 1. Main Vegetable Spawner Timeline (repeats `GAME_DURATION_REPEATS` times)
            vegTL = gsap.to(window, {
                duration: 1.5, // Time between spawns (can be adjusted for difficulty)
                repeat: GAME_DURATION_REPEATS, 
                onRepeat: addVeg,
                onComplete: gameEnd,
                paused: true // Start paused until timer is set
            });
            
            // Ensure first veg spawns immediately
            addVeg();

            // Total duration of the game timer
            gameTimerDuration = vegTL.totalDuration(); 

            // 2. Timer Animation Timeline
            timerTL = gsap.timeline({ onComplete: gameEnd, paused: true })
                .to(timerFace, { 
                    rotate: -50, 
                    ease: 'power1.in', 
                    duration: 0.5 
                }, 0)
                .to(timerFace, { 
                    rotate: 0, 
                    ease: 'none', 
                    duration: gameTimerDuration
                }, 0.5);

            // Start all timelines
            vegTL.play();
            timerTL.play();
        }


        // --- Event Handlers ---

        startButton.onclick = startGame;

        /**
         * Handles the click on the timer icon to reset the game (only visible after gameEnd).
         */
        function handleTimerClick() {
            if (!props.isGameRunning && vegNum > 0) { // Check if the game has ended and was played
                startGame();
            }
        }

        /**
         * Handles the pointer down (slice action).
         * @param {PointerEvent} e 
         */
        const handlePointerDown = (e) => {
            if (!props.isGameRunning) return;

            gsap.timeline({ defaults: { duration: 0.2, ease: 'back.out(4)' } })
                .to(dagger, { rotate: 200, xPercent: -30, scale: 0.8 }, 0)
                .to(follower, { filter: 'drop-shadow(5px 7px 2px rgba(0,0,0,0.3))' }, 0)
                .add(() => {
                    checkSlice(e);
                }, 0.1); // Delay the slice check slightly after the dagger movement starts
        };

        /**
         * Handles the pointer up (dagger reset).
         */
        const handlePointerUp = () => {
            if (!props.isGameRunning) return;

            gsap.to(dagger, { duration: 0.2, rotate: 125, xPercent: -50, scale: 1 });
            gsap.to(follower, { duration: 0.2, filter: 'drop-shadow(30px 30px 4px rgba(0,0,0,0.1))' });
        };

        /**
         * Handles pointer movement (cursor follow).
         * @param {PointerEvent} e 
         */
        const handlePointerMove = (e) => {
            if (!props.isGameRunning) return;

            const { x, y } = getPointerCoords(e);
            
            // Calculate direction for rotation effect
            props.x = gsap.getProperty(follower, 'x');
            props.dir = (x > props.x) ? 1 : -1; // 1 for moving right, -1 for moving left

            // Smoothly move the follower (cursor)
            gsap.to(follower, { y: y, duration: 0.1, ease: 'power1.out' }); // Y is quick
            gsap.to(follower, { 
                x: x, 
                duration: 0.5, 
                ease: 'expo.out', 
                onUpdate: () => {
                    // Calculate rotation based on speed difference
                    const rot = Math.abs(x - gsap.getProperty(follower, 'x')) / 4;
                    // Apply rotation, clamped to prevent extreme angles
                    gsap.set(follower, { rotate: gsap.utils.clamp(0, 33, rot) * props.dir });
                }
            });
        };

        // --- Initial Load ---
        window.onload = () => {
            // Position the follower initially outside the screen
            gsap.set(follower, { x: -100, y: -100 });
            // Show the start screen
            gsap.set(startScreen, { autoAlpha: 1, pointerEvents: 'auto' });

            // Add listener for resizing to improve responsiveness (though GSAP handles most)
            window.addEventListener('resize', () => {
                // This ensures the game area dimensions are always current
                gsap.set(stageBg, { width: window.innerWidth, height: window.innerHeight });
                gsap.set(stageFg, { width: window.innerWidth, height: window.innerHeight });
            });
        };
    </script>
</body>
</html>